// Мотивация
// ---------
//
// Мы программируем интерактивные векторные визуализации. Визуализации удовлетворяют двум требованиям.
//
// 1. Она перерисовывается при изменении данных, положений фильтров, размеров экрана. `SVG`-статику программировать не надо, её рисуют в векторном редакторе.
// 2. Визуализация — веб-приложение или его часть. Это задаёт требования к коду: понятный, максимально модульный, переиспользуемый.
// 
// Создание такой визуализации — **проблема**. Её не решают `Angular` и `D3`.
// 
// Проблемы
// --------
// 
// `Angular` замедляет страницу, долго реагирует на любой чих. Движение мыши, нажатие клавиши, сработавший таймер — любое действие может подвесить страницу на пару секунд. Такую визуализацию стыдно называть интерактивной.
// 
// `D3` не способствует организации кода. Код без организации разбухает, наполняется хаками и сложной логикой в неожиданных местах. Такому коду место на `jsfiddle`, но не в продакшне. Его дорого поддерживать, трудно интегрировать и всё время хочется выкинуть.
// 
// Решение
// -------
// 
// Используем `Angular`, но делегируем отрисовку элементов `D3`. Это делает код модульным, но быстрым.
// Вместо динамических параметров в шаблонах, используем события `Angular`. Это позволяет запускать перерисовку сразу после события без лишних проверок.
// 
// Используем три `Angular`-события:
//
// Событие `renderRequired` с параметром `transition` — «обновляем всё, вот с такой анимацией».
//
// Визуализация отправляет `renderRequired` из контроллера или директивы, когда узнаёт о изменениях данных.
//
// Например, директива [renderOnResize] будет вызывать событие `renderRequired` при изменении размеров экрана.
//[renderOnResize]: /blocks/renderOnResize.html
// `transition` — объект, настройки анимации для всей страницы, например:

var transition = {
    duration: 300,
    ease: 'linear'
};
$scope.$emit('renderRequired', transition);

// Событие `startRender` с параметром `transition` — «графики, перерисовывайтесь, с вот такой анимацией».
// `startRender` запускается после одного или нескольких подряд `renderRequired`.

var unbind = $rootScope.$on('startRender', function ($event, transition) {
    /*...*/
});
$scope.$on('$destroy', unbind);

// Событие `render` с параметрами `render`, `transition` — «элементы, перерисовывайтесь, вот параметры и анимация».
// `render` запускает директива графика после получения `startRender`.
// Параметр `render` — объект, настройки графика. Обязательно содержит поле `margin`, его используют оси, шкалы и т.д.
// Например:

var margin = {
    top: 30,
    right: 80,
    bottom: 30,
    left: 35
};
var render = {
    margin: margin
};

var unbind = $rootScope.$on('startRender', function ($event, transition) {
    $scope.$broadcast('render', render, transition);
});
$scope.$on('$destroy', unbind);

// Элемент графика получает `render` и перерисовывается, сервис `applyTransition` применяет анимацию:

$scope.$on('render', function ($event, render, transition) {
    var target = applyTransition(d3element, transition);
    /*...*/
});

// Если нужно перерисовать только один график — он запускает `render` в своём `$scope`:

$scope.$broadcast('render', render, transition);

// Блоки
// -----
// Блоки как в БЭМ, переиспользуемые компоненты.
// * [backedText] — текст с настраиваемой подложкой;
// * [dropdownFilter] — выпадающий фильтр;
// * [bottomLine] — линия от текстового элемента до низа контейнера.
//[backedText]: /blocks/backedText.html
//[dropdownFilter]: /blocks/backedText.html
//[bottomLine]: /blocks/bottomLine.html

// Директивы
// ---------
// «Строительные блоки» `angular`-страниц.
// * [axis] — рисует ось и линии сетки;
// * [bindScope] — даёт доступ к `$scope` в `D3`-обработчиках;
// * [fillSvg] — задаёт прямоугольнику размер рабочей области;
// * [margin] — сдвигает целевой `SVG`-элемент на отступ, указанный в параметрах `render`;
// * [render] — вызывает переданную функцию при получении события `render`;
// * [renderLoop] — обеспечивает рассылку `render`-сообщений;
// * [renderOnResize] — запускает перерисовку всех графиков при изменении размеров экрана;
// * [sizeToScales] — задаёт `range` переданным шкалам на основе размеров элемента с учётом отступов.
//[axis]: /blocks/axis.html
//[bindScope]: /blocks/bindScope.html
//[fillSvg]: /blocks/fillSvg.html
//[margin]: /blocks/margin.html
//[render]: /blocks/render.html
//[renderLoop]: /blocks/renderLoop.html
//[renderOnResize]: /blocks/renderOnResize.html
//[sizeToScales]: /blocks/sizeToScales.html

// Сервисы
// -------
// Полезные функции.
// * [applyTransition] — применяет `transition` к `D3`-выборке, возвращая новую выборку;
// * [callMethods] — вызывает функции объекта, настраивая его;
// * [last] — возвращает последний элемент массива;
// * [multifilter] — стандартный фильтр, удобен для проверки массива объектов на соответствие набору свойств;
// * [numberDeclension] — склоняет числа;
// * [removePrototype] — превращает специфичный объект (например, результат `getBBox()`) в обычный;
// * [roundTo] — округляет числа до заданной точности;
// * [toGrayscale] — приводит цвет к серому оттенку.
//[applyTransition]: /blocks/applyTransition.html
//[callMethods]: /blocks/callMethods.html
//[last]: /blocks/last.html
//[multifilter]: /blocks/multifilter.html
//[numberDeclension]: /blocks/numberDeclension.html
//[removePrototype]: /blocks/removePrototype.html
//[roundTo]: /blocks/roundTo.html
//[toGrayscale]: /blocks/toGrayscale.html

// Фильтры
// -------
// Доступные в любом `angular`-шаблоне функции.
// * [preventNaN] — заменяет `NaN` на `undefined`;
// * [trust] — фильтр для прохода [ангуляровской проверки](https://blocks.angularjs.org/api/ng/service/$sce) небезопасного контента;
// * [services] — «превращает» сервисы в фильтры.
//[preventNaN]: /blocks/preventNaN.html
//[trust]: /blocks/trust.html
//[services]: /blocks/services.html
//
// Для перехода между страницами документации используйте навигацию в правом верхнем углу экрана.

// Словарик
// --------
// - событие, `event` — аналогично `DOM`-событиям, в `Angular` есть свои, используются для уведомлений, например: загрузились данные, изменился режим;
// - скоуп, `$scope` — хранилище данных, его удобно использовать в шаблонах, контроллерах, директивах;
// - воч, `$watch` — отслеживание изменений данных в `$scope` из кода;
// - фильтр, `filter` — функция для вызова из шаблона, простая и «дешёвая» (минимум кода и зависимостей);
// - контроллер, `controller` — функция, вызывающаяся на участке страницы, описывает поведение, загружает данные;
// - сервис, `service` — функция, использующаяся в контроллере или директиве;
// - директива, `directive` — блок документа или логический элемент, заменяет `DOM`-элемент или дополняет его, используется в шаблонах страниц и других директив;
// - шаблон, `template` — `HTML`-файл с вёрсткой директивы.
//
