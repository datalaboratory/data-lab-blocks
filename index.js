// Мотивация
// ---------
// 
// Мы программируем интерактивные векторные визуализации. Визуализации удовлетворяют двум требованиям.
// 
// 1. Она перерисовывается при изменении данных, положений фильтров, размеров экрана. `SVG`-статику программировать не надо, её рисуют в векторном редакторе.
// 2. Визуализация — веб-приложение или его часть. Это задаёт требования к коду: понятный, максимально модульный, переиспользуемый.
// 
// Создание такой визуализации — **проблема**. Её не решают Ангуляр и `D3`.
// 
// Проблемы
// --------
// 
// Ангуляр замедляет страницу, долго реагирует на любой чих. Движение мыши, нажатие клавиши, сработавший таймер — любое действие может подвесить страницу на пару секунд. Такую визуализацию стыдно называть интерактивной.
// 
// `D3` не способствует организации кода. Код без организации разбухает, наполняется хаками и сложной логикой в неожиданных местах. Такому коду место на `jsfiddle`, но не в продакшне. Его дорого поддерживать, трудно интегрировать и всё время хочется выкинуть.
// 
// Решение
// -------
// 
// Используем Ангуляр, но делегируем отрисовку элементов `D3`. Это делает код модульным, но быстрым.
// Вместо динамических параметров в шаблонах, используем события Ангуляра. Это позволяет запускать перерисовку сразу после события и без тысяч проверок.
// 
// Используем три Ангуляр-события:
// 
// Событие `renderRequired` с параметром `transition` — «нужно перерисовать всё, с вот такой анимацией», `renderRequired` может запустить контроллер или директива, когда узнаёт о изменениях данных.
// `transition` — объект, настройки анимации для всей страницы, например:

var transition = {
    duration: 300,
    ease: 'linear'
};
$scope.$emit('renderRequired', transition);

// Событие `startRender` с параметром `transition` — «графики, перерисовывайтесь, с вот такой анимацией»
// `startRender` запускается после одного или нескольких подряд `renderRequired`.

$rootScope.$on('startRender', function ($event, transition) {
    /*...*/
});

// Событие `render` с параметрами `render`, `transition` — «элементы, перерисовывайтесь, вот параметры и анимация».
// `render` запускает директива графика после получения `startRender`.
// Параметр `render` — объект, настройки графика. Обязательно содержит поле margin, его используют оси, шкалы etc.
// Например:

var margin = {
    top: 30,
    right: 80,
    bottom: 30,
    left: 35
};
var render = {
    margin: margin
};

$rootScope.$on('startRender', function ($event, transition) {
    $scope.$broadcast('render', render, transition);
});
    
// Элемент графика получает `render` и перерисовывается, сервис `applyTransition` применяет анимацию:

$scope.$on('render', function ($event, render, transition) {
    var target = applyTransition(d3element, transition);
    /*...*/
});

// Если нужно перерисовать только один график — он запускает `render` в своём `$scope`:

$scope.$broadcast('render', render, transition);

// Блоки
// -----
// Блоки как в БЭМ, переиспользуемые компоненты.
// * [backedText](/blocks/backedText.html) — текст с настраиваемой подложкой;
// * [dropdownFilter](/blocks/backedText.html) — выпадающий фильтр;
// * [bottomLine](/blocks/bottomLine.html) — линия от текстового элемента до низа контейнера.

// Директивы
// ---------
// «Строительные блоки» `angular`-страниц.
// * [axis](/blocks/axis.html) — рисует ось и линии сетки;
// * [bindScope](/blocks/bindScope.html) — даёт доступ к `$scope` в `D3`-обработчиках;
// * [fillSvg](/blocks/fillSvg.html) — задаёт прямоугольнику размер рабочей области;
// * [margin](/blocks/margin.html) — сдвигает целевой `SVG`-элемент на отступ, указанный в параметрах `render`;
// * [render](/blocks/render.html) — вызывает переданную функцию при получении события `render`;
// * [renderLoop](/blocks/renderLoop.html) — обеспечивает рассылку `render`-сообщений;
// * [renderOnResize](/blocks/renderOnResize.html) — запускает перерисовку всех графиков при изменении размеров экрана;
// * [sizeToScales](/blocks/sizeToScales.html) — задаёт `range` переданным шкалам на основе размеров элемента с учётом отступов.

// Сервисы
// -------
// Полезные функции.
// * [applyTransition](/blocks/applyTransition.html) — применяет `transition` к `D3`-выборке, возвращая новую выборку;
// * [callMethods](/blocks/callMethods.html) — вызывает функции объекта, настраивая его;
// * [last](/blocks/last.html) — возвращает последний элемент массива;
// * [multifilter](/blocks/multifilter.html) — стандартный фильтр, удобен для проверки массива объектов на соответствие набору свойств;
// * [numberDeclension](/blocks/numberDeclension.html) — склоняет числа;
// * [removePrototype](/blocks/removePrototype.html) — превращает специфичный объект (например, результат `getBBox()`) в обычный;
// * [roundTo](/blocks/roundTo.html) — округляет числа до заданной точности;
// * [toGrayscale](/blocks/toGrayscale.html) — приводит цвет к серому оттенку.

// Фильтры
// -------
// Доступные в любом `angular`-шаблоне функции.
// * [preventNaN](/blocks/preventNaN.html) — заменяет `NaN` на `undefined`;
// * [trust](/blocks/trust.html) — фильтр для прохода ангуляровской [проверки](https://blocks.angularjs.org/api/ng/service/$sce) небезопасного контента;
// * [services](/blocks/services.html) — «превращает» сервисы в фильтры.

// Для перехода между страницами документации используйте навигацию в правом верхнем углу экрана.

// Словарик
// --------
// - событие, event — аналогично DOM-событиям, в Ангуляре есть свои, используются для уведомлений, например: загрузились данные, изменился режим;
// - скоуп, $scope — хранилище данных, его удобно использовать в шаблонах, контроллерах, директивах;
// - фильтр, filter — функция для вызова из шаблона, простая и «дешёвая»;
// - контроллер, controller — функция, вызывающаяся на участке страницы, описывает поведение, загружает данные;
// - сервис, service — функция, использующаяся в контроллере или директиве;
// - директива, directive — блок документа или логический элемент, заменяет html-элемент или дополняет его, используется в шаблонах страниц и других директив;
// - шаблон, template —html-файл с вёрсткой директивы.
